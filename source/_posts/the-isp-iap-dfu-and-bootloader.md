---
title: 关于ISP、IAP、DFU和bootloader
date: 2012-08-27 19:46:22
tags:
categories: 软硬兼施
---

这是嵌入式开发中常用的几个专业术语，其诞生的背景和其具体作用大概如下：

在很久很久以前，那是8051单片机流行的时代，做单片机开发都需要一个专用工具，就是单片机的编程器，或者叫烧写器。说“烧”写一点不为过，当年的经典芯片AT89C51在编程时需要十几伏的高电压，加在一个特定的引脚上，才能进入编程。对于某款芯片的编程，都有一个特定的时序，这个时序通常在芯片的datasheet里进行描述并以硬件实现。另外在编程器里的也有一个MCU，这其中使用软件产生这个时序，从而对目标芯片进行编程。电脑通过串口把程序发到编程器，编程器按照规定的时序把程序送入目标芯片。

<!--more-->

但是这种编程模式有几个问题，首先就是需要为特定的芯片购买特定的编程器。这种编程器通常比较昂贵，且只能用于特定型号的MCU. 对于企业来说，编程器的成本算不了什么，但更大的问题是，编程时我们必须把待编程的芯片从产品上拆下来，插到编程器上，编程后再安装回产品中。这种方法对于双列直插式的芯片也许是可行的。但对于现在日益流行的表面贴装技术是很不可行的，尤其是BGA封装的芯片，通常需要专业设备才能拆卸，拆下后需要重新植球才能焊接。。。为了更新固件而将其从高密度的PCB板上拆下来，是非常不可行的。

为了能不把芯片拆下来就更新程序，人们发明了一种叫ISP的技术，即在系统编程。在系统编程就是通过串口或者其他通用的通用通信接口，为芯片编程。在产品上可以预留一个串口，需要更新时，只要把产品插到电脑上，通过串口把程序传到芯片里，就完成了更新操作。ISP技术的实现，其实就是依赖于芯片在出厂时预先烧写的bootloader程序，bootloader还有很多不同的叫法，比如ISP服务程序（STC宏晶的51单片机这么叫）、bootstrap（MSP430的BSL编程这么叫）等等。但本质上都是相同的。bootloader在芯片复位（或者上电）时，会优先于用户自己的代码启动。这段代码会首先检测芯片的指定引脚上有没有特定的信号，如果没有，则跳入用户程序执行。否则就按照bootloader特定的通信协议，与计算机进行握手，并最终触发计算机将新的程序通过通用接口（如串口）传送到芯片。然后bootloader通过软件的方式（当然需要硬件支持），擦除用户程序区，将新的程序写入到指定的位置。另外提到的是，bootloader是由各个芯片厂家自己写的，因此不是通用的。尽管都是用串口，但通信协议是不同的。比如像国产垃圾STC单片机，通信协议甚至是保密的。因此通常需要厂家提供的专用ISP软件（flash loader）才能给芯片编程。

另外，比ISP更先进一点的一个技术叫IAP，即在应用编程。IAP技术允许用户程序修改flash。说白了IAP就是允许用户自定义bootloader，或者说有2个bootloader，一个bootloader是芯片出厂时固化的，另一个是用户自定义的。自定义的bootloader在固化的bootloader之后启动。也许你就要问了，用户自定义的bootloader不就是用户程序吗？其实它跟普通用户程序的区别就是它不会那么容易的被擦除。。。一般是先用专用软件，调用固化的bootloader，来写入自定义的bootloader，然后自定义的bootloader利用能写flash的能力，来给芯片写入新的程序。
为什么需要自定义bootloader呢？默认的bootloader需要在固定引脚，通过串口，以固定的协议传送程序。如果你对这个过程的任何一点不满意，那你就要自定义bootloader喽~

再说说DFU，这个名词通常是针对USB设备说的。因为现在的设备基本都是USB了，没用串口的了。。。很多MCU也内置了USB的支持。DFU是Device Firmware Upgrade的缩写，在我的理解中，DFU模式就是支持USB的bootloader。。。DFU模式通常需要特定的驱动程序，因为现在的芯片USB接口通常工作于VCP（Virtual COM Port）模式，插到电脑上后会虚拟成一个串口设备。而DFU模式则于此不同。VCP模式下，PC端是一个串口驱动程序，MCU端是用户程序。而DFU模式下，PC端是DFU驱动程序，MCU端是bootloader。DFU模式的bootloader通常是用户自定义的，并通过固化的bootloader由串口刷入。

进入bootloader程序通常有两种方式，一种是硬件复位（或者掉电），即按板上的复位按钮。芯片复位后会先执行bootloader。第二种方式是以软复位的方式进入的，软复位通常是通过PC发送一串指定的指令，用户程序中会通过中断服务程序检测到并处理这些指令。满足触发条件后，芯片将执行软复位，并将指定的地址装入PC寄存器，从而通过软件的方式跳入bootloader程序。

最后我们来看一下Arduino和Maple板子的刷写方式。

Arduino板上有两个MCU，一个是我们都知道的执行程序的那个MCU，它里面刷写了Arduino自定义的bootloader。另外一个是USB接口附近的一个QFN封装的小芯片，它也是一片MCU，只不过是带USB支持的。在这里它完成USB转串口的功能。更重要的是，它可以监测PC发来的指令流，其中就包含了复位指令。收到USB发来的复位指令后，它会在目标MCU的复位脚加一个负脉冲，使得目标MCU复位，进而将下载指令流放到目标MCU的串口上。使得目标MCU的bootloader检测到，从而完成下载。
Maple只有一个MCU，因此从USB收到下载指令后，只不过复位的不是别的芯片，而是复位自己。将自己复位到DFU模式，从而利用bootloader从USB下载程序。
